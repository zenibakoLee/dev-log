# Encryption & Decryption

> [암호화](https://ko.wikipedia.org/wiki/암호화)
>

> [해시 함수](https://ko.wikipedia.org/wiki/해시_함수)
>

> [암호화 해시 함수](https://ko.wikipedia.org/wiki/암호화_해시_함수)
>

> [Bcrypt](https://ko.wikipedia.org/wiki/Bcrypt)
>

> [Scrypt](https://en.wikipedia.org/wiki/Scrypt)
>

> [Argon2](https://ko.wikipedia.org/wiki/Argon2)
>

> [Balloon hashing](https://en.wikipedia.org/wiki/Balloon_hashing)
>

암호화는 평문(원래 값)을 남들이 알기 어렵도록 변환해서 암호문을 만드는 작업이다. 암호문을 다시 평문으로 변환하는 작업은 복호화라고 한다. 일반적으로는 암호문을 평문으로 되돌릴 수 있지만, 평문으로 되돌릴 수 없는
암호화도 있다.

- 일반적인 암호화/복호화: 평문 ↔ 암호문
- 단방향 암호화: 평문 → 암호문 (비가역적)

사용자의 패스워드를 평문으로 저장하거나 복호화 가능한 형태로 암호화해서 저장하지 않고 평문으로 되돌릴 수 없는 형태로 암호화해서 저장해서, 혹시라도 서버에 저장된 패스워드가 유출됐을 때 사용자의 패스워드(평문)이
직접적으로 드러나지 않게 한다.

원래의 패스워드로 복호화가 불가능하다면 어떻게 올바른 패스워드로 로그인을 시도했는지 알 수 있을까? 사용자가 (로그인을 하려고) 입력한 패스워드를 암호화해서 저장된 (즉, 이미 암호화된) 값과 비교함으로써 패스워드를
올바르게 입력했는지 확인한다.

예를 들면 다음과 같다:

1. 준비: 회원 가입할 때 입력한 패스워드로 “password”를 입력.
    - 서버에서 단방향 암호화하면 “6f9078fa76fabdc827a86c6d33e52310”를 얻게 된다.
    - 이 값을 DB에 저장하면 준비가 끝난다.
2. 시나리오 #1: 로그인할 때 패스워드로 “password”를 입력.
    - 서버에서 단방향 암호화하면 “6f9078fa76fabdc827a86c6d33e52310”를 얻게 된다.
    - 이 값을 DB에 있는 값과 비교하면, 같기 때문에 로그인이 성공하게 된다.
3. 시나리오 #2: 로그인할 때 패스워드로 “test”를 입력.
    - 서버에서 단방향 암호화해서 “9942462daae6b66431866c1b5769cfc4”를 얻게 된다.
    - 이 값을 DB에 있는 값과 비교하면, 다르기 때문에 로그인이 실패하게 된다.

[해시 함수](https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98)
![img.png](../../resources/security_encryption_hash.png)

암호용 해시 함수는 매핑된 해싱 값만을 알아가지고는 원래 입력 값을 알아내기 힘들다는 사실에 의해 사용될 수 있다

단방향 암호화를 위해 암호학적 해시 알고리즘을 사용하고, 암호학적 해시 알고리즘은 다음의 성질을 갖는다.

1. 역상(pre-image) 저항성: 해시 값(암호문)에서 원래 값(평문)을 찾을 수 없어야 한다.
2. 제2 역상 저항성: 원래 값과 다르지만 동일한 해시 값으로 변환되는 다른 값을 찾을 수 없어야 한다.
3. 충돌 저항성: 동일한 해시 값으로 변환되는 두 개의 값을 찾을 수 없어야 한다.

아주 간단한 해시 함수 “f(x) = x % 10”가 암호학적 해시 알고리즘인지 검증해 보자. 이걸 사용하면, 평문(원래 값)이 13일 때 암호문(해시 값)은 3이 된다.

1. 역상 저항성: 암호문 3을 보고 원래 값을 바로 찾는 건 쉽지 않다. 하지만 몇 번 반복적으로 시도했을 때 원래 값이 13이라는 걸 찾을 가능성이 상당히 높다.
2. 제2 역상 저항성: 암호문 3을 보고 원래 값을 바로 찾을 수는 없지만, 동일한 암호문을 만드는 3, 23, 33 등의 값을 찾아낼 수 있다.
3. 충돌 저항성: 우리는 1, 11, 21, 31 등의 평문이 1이라는 동일한 암호문으로 변환된다는 걸 쉽게 알아낼 수 있다.

즉, 해시 함수 “f(x) = x % 10”는 안전하게 사용할 수 있는 해시 알고리즘이 아니다.

사용자의 패스워드를 단방향으로 암호화하기 위해 예전에는 bcrypt나 scrypt를 많이 썼는데, 최근에는 Argon2나 Balloon을 사용한다. Argon2는 2015년 Password Hashing
Competition에서 우승했고, Spring Security에서도 지원하고 있으니 특별한 경우가 아니라면 이걸 사용하자.

- [Argon2PasswordEncoder](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/crypto/argon2/Argon2PasswordEncoder.html)

---

### Salt

![img.png](../../resources/security_encryption_salt.png)

솔트는 해시 함수를 사용할 때 원본 문자열에 추가되는 임의의 데이터 문자열입니다. 일반적으로 비밀번호 보호를 강화하고 무차별 대입 공격으로부터 보호하는 데 사용됩니다. 두 명 이상의 사용자가 동일한 비밀번호를 사용할
수 있으므로 유사한 해시가 저장됩니다. 무작위 문자열을 사용하면 매번 고유한 해시가 생성되므로 솔트는 이러한 일이 발생하지 않도록 방지합니다.

공격자가 침해된 데이터베이스에 액세스하여 저장된 중복 해시를 본 경우 솔팅이 없거나 약한 알고리즘이 사용되어 충돌이 발생하고 있기 때문일 수 있습니다.
